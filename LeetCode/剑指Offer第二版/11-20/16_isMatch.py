# 正则表达式匹配
# 请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa
# "与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。

# DP思路：
# dp五部曲:(参考最高赞的思路)
#         设原始串s的长度为m,模式串p的长度为n
#         注意定义:'*'表示它前面的(一个)字符可以出现任意次（含0次）!注意是一个
#         1.状态定义:设dp[i][j]为考虑s[0,i-1],p[0,j-1]时,是否能匹配上,匹配上就为true
#         2.状态转移:
#             2.1 p[j-1]为非'*'
#                 2.1.1 若p[j-1]==s[i-1](必定为'a'-'z'),继续看dp[i-1][j-1]
#                 2.1.2 若p[j-1]为'.',直接看dp[i-1][j-1]
#             2.2 p[j-1]为'*'
#                 2.2.1 若p[j-2]==s[i-1](必定为'a'-'z'),则继续向前看dp[i-1][j]
#                     因为对于p[0,j-1]来说,s[i-1]是冗余匹配可以由p[j-2]*补充
#                 2.2.2 p[j-2]为'.',则'.'匹配了s[i-1],可以继续往前看dp[i-1][j]
#                     注意这里是".*"的情形,也就是"万能串",生成"......"可以匹配任何非空s
#                 2.2.3 此时p[j-2]为'a'-'z',且p[j-2]!=s[i-1],"p[j-2]*"直接废掉,看dp[i][j-2]
#             其中2.1.1和2.1.2可以合并为一种情形;2.2.1和2.2.2可以合并为一种情形
#         3.初始化:
#             3.1 空的p
#                 3.1.1 可以匹配空的s,dp[0][0]=true
#                 3.1.2 不可以匹配非空的s,dp[i][0]=false,i∈[1,m-1]
#             3.2 空的s
#                 3.2.1 可以匹配空的s,dp[0][0]=true
#                 3.2.2 可能可以匹配非空的p,要经过计算如"a*b*c*"
#             3.3 非空的p与非空的s,要经过计算
#         4.遍历顺序:显然是正序遍历
#         5.返回形式:直接返回dp[m][n]就表示考虑s[0,m-1],j[0,n-1]是否能匹配上
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        n, m = len(s) + 1, len(p) + 1
        dp = [[False] * m for _ in range(n)]

        for i in range(n):
            for j in range(m):
                # 分成空正则和非空正则两种
                if j == 0:
                    dp[i][j] = i == 0
                else:
                    # 非空正则分为两种情况 * 和 非*
                    if p[j - 1] != '*':
                        if i > 0 and (s[i - 1] == p[j - 1] or p[j - 1] == "."):
                            dp[i][j] = dp[i - 1][j - 1]
                    else:
                        # 碰到 * 了，分为看和不看两种情况
                        # 不看
                        if j >= 2:
                            dp[i][j] |= dp[i][j - 2]
                        # 看
                        if i >= 1 and j >= 2 and (s[i - 1] == p[j - 2] or p[j - 2] == "."):
                            dp[i][j] |= dp[i - 1][j]
        return dp[n - 1][m - 1]


if __name__ == '__main__':
    sl = Solution()
    print(sl.isMatch('aaa', 'c*a*b'))
